#include "my_classifier.h"
#include <iostream>
#include <fstream>
#include <string>
#include <stdlib.h>     /* srand, rand */
#include <time.h>       /* time */
#include <algorithm>
#include <iterator>

//random-number generation functor
class ExampleRnd
{
public:
    size_t operator( )(size_t n) const
    { return(rand( )%n ); }
};

void MyClassifier::init(int argc, char **argv)
{
    ros::init(argc, argv, "my_classifier");
    n_ = new ros::NodeHandle ( "~" );
    n_->getParam ( "test_filename", test_filename_ );
    n_->getParam ( "training_dir", training_dir_ );
    n_->getParam ( "force_retrain", force_retrain_ );
    std::string indices_prefix = "object_indices_";

    bf::path training_dir_bf = training_dir_;
    if(bf::is_directory(training_dir_))
    {
        std::vector<std::string> training_filenames;
        std::string empty_string = "";
        std::string extension = "txt";

        pPCSource_->getFilesInDirectory(training_dir_bf, empty_string, training_filenames, extension);
        for(int i=0; i<training_filenames.size(); i++)
        {
            std::cout << training_filenames[i] << std::endl;
        }
        num_classes_ = training_filenames.size();

        if(training_filenames.empty())
        {
            std::cerr << "There are no training files in " << training_dir_ << ". Re-Training..." << std::endl;
            force_retrain_ = true;
        }
    }
    else
    {
        std::cerr << "Training directory(" << training_dir_ << ") does not exist. Re-Training..." << std::endl;
        force_retrain_ = true;
    }

    // load a .pcd file, extract indices of object and classify
    if(bf::exists(test_filename_))
    {
        std::string directory, filename;
        char sep = '/';
#ifdef _WIN32
        sep = '\\';
#endif

        size_t position = test_filename_.rfind(sep);
        if (position != std::string::npos)
        {
            directory = test_filename_.substr(0, position);
            filename = test_filename_.substr(position+1, test_filename_.length()-1);
        }

        std::stringstream path_oi;
        path_oi << directory << "/" << indices_prefix << filename ;

        if(bf::exists(path_oi.str()))
        {
            pcl::PointCloud<PointT>::Ptr cloud (new pcl::PointCloud<PointT>);
            pcl::io::loadPCDFile (test_filename_, *cloud);

            pcl::PointCloud<IndexPoint> obj_indices_cloud;
            pcl::io::loadPCDFile (path_oi.str(), obj_indices_cloud);
            pcl::PointCloud<PointT>::Ptr pFilteredCloud;
            pFilteredCloud.reset(new pcl::PointCloud<PointT>());
            pcl::PointIndices indices;
            indices.indices.resize(obj_indices_cloud.points.size());
            for(size_t kk=0; kk < obj_indices_cloud.points.size(); kk++)
                indices.indices[kk] = obj_indices_cloud.points[kk].idx;
            pcl::copyPointCloud(*cloud, indices, *pFilteredCloud);

            this->setInputCloud(*pFilteredCloud);
            std::cout << "Test point cloud and indices loaded for file: " << test_filename_ << std::endl;
        }
    }
}

void MyClassifier::setInputCloud(pcl::PointCloud<PointT> &cloud)
{
    *pInputCloud_ = cloud;
}

std::vector<std::vector<double> > MyClassifier::readMatrixFromFile(std::string filename, std::string delimiter)
{
    std::vector<std::vector<double> > data;

    std::ifstream file;
    file.open(filename.c_str());

    if(!file.is_open())
    {
        std::cerr << "Failed to open file " << filename << std::endl;
        return data;
    }
    std::string line;
    while( std::getline(file,line))
    {
        std::vector<double> data_tmp;

        size_t pos = 0;
        std::string token;
        while ((pos = line.find(delimiter)) != std::string::npos) {
            token = line.substr(0, pos);
            line.erase(0, pos + delimiter.length());
            data_tmp.push_back(atof(token.c_str()));
        }
        data_tmp.push_back(atof(line.c_str()));
        data.push_back(data_tmp);
    }
}

void MyClassifier::computeSvmModel(std::vector<std::vector<double> >data_train, std::vector<double> target_train)
{
    svm::svm_problem *svm_prob = new svm::svm_problem;
    svm_prob->l = data_train.size(); //number of training examples
    svm_prob->x = new svm::svm_node *[svm_prob->l];
    for(int i = 0; i<svm_prob->l; i++)
        svm_prob->x[i] = new svm::svm_node[data_train[i].size()+1];  // add one additional dimension and set that index to -1 (libsvm requirement)
    svm_prob->y = new double[svm_prob->l];

    for(int i=0; i<svm_prob->l; i++)
    {
        for(int kk=0; kk<data_train[i].size(); kk++)
        {
            svm_prob->x[i][kk].value = data_train[i][kk];
            svm_prob->x[i][kk].index = kk+1;
            svm_prob->y[i] = target_train[i];
        }
        svm_prob->x[i][data_train[i].size()].index = -1;
    }
    svm_mod_ = svm::svm_train(svm_prob, svm_para_);
}

void MyClassifier::initSVM()
{
    svm_para_->svm_type = svm::C_SVC;
    svm_para_->kernel_type = svm::RBF;
    //svm_para->degree = 2;
    svm_para_->gamma = 0.01;// default 1/k;
    //svm_para->coef0 = 1;

    svm_para_->cache_size = 100;
    svm_para_->eps = 0.001;
    svm_para_->C = 10;
    svm_para_->nr_weight = 0;
    svm_para_->weight_label = NULL;
    svm_para_->weight = NULL;
    //svm_para->nu = 0.5;
    //svm_para->p = 1;
    svm_para_->shrinking = 1;
    svm_para_->probability = 0;
}

double MyClassifier::testSVM(const std::vector<std::vector<double> > & data_test, std::vector<double> &target_pred, const std::vector<double> &target_test)
{
    size_t num_falsely_classified=0, num_correctly_classified=0;

    target_pred.resize (data_test.size());

    for(int i=0; i<data_test.size(); i++)
    {
        svm::svm_node *svm_n_test = new svm::svm_node[data_test[i].size()+1];

        for(int kk=0; kk<data_test[i].size(); kk++)
        {
            svm_n_test[kk].value = data_test[i][kk];
            svm_n_test[kk].index = kk+1;
        }
        svm_n_test[data_test[i].size()].index = -1;
        target_pred[i] = svm::svm_predict(svm_mod_, svm_n_test);

        if(target_test.size()>i)
        {
            if(target_pred[i] == target_test[i])
                num_correctly_classified++;
            else
                num_falsely_classified++;
        }
    }
    if (num_correctly_classified + num_falsely_classified == 0)
        return 0;
    return static_cast<double>(num_correctly_classified)/(num_correctly_classified + num_falsely_classified);
}

void MyClassifier::dokFoldCrossValidation(std::vector<std::vector<double> >data_train, std::vector<double> target_train, int k)
{
    double bestC=0.001, bestGamma = 0.01, bestTestPerformanceValue=0;

    std::vector<double> performance(k);

    for(double C = bestC; C < 100.1; C = 10*C)
    {
        for(double gamma = bestGamma; gamma < 1000.1; gamma = 10*gamma)
        {
            svm_para_->C = C;
            svm_para_->gamma = gamma;
            std::cout << "Computing svm for C=" << C << " and gamma=" << gamma << std::endl;
            double avg_performance = 0;
            for(int current_val_set_id = 0; current_val_set_id < k; current_val_set_id++)
            {
                std::vector<std::vector<double> > data_train_sub;
                std::vector<std::vector<double> > data_val;
                std::vector<double> target_train_sub;
                std::vector<double> target_val;

                int subset_size = std::floor(static_cast<double>(data_train.size())/k);
                for(int i=0; i < current_val_set_id * subset_size; i++)
                {
                    data_train_sub.push_back(data_train[i]);
                    target_train_sub.push_back(target_train[i]);
                }
                for(int i = current_val_set_id * subset_size; i < (current_val_set_id + 1) * subset_size; i++)
                {
                    data_val.push_back(data_train[i]);
                    target_val.push_back(target_train[i]);
                }
                for(int i=(current_val_set_id + 1) * subset_size; i<data_train.size(); i++)
                {
                    data_train_sub.push_back(data_train[i]);
                    target_train_sub.push_back(target_train[i]);
                }
                computeSvmModel(data_train_sub, target_train_sub);
                std::vector<double> target_pred;
                performance[current_val_set_id] = testSVM(data_val, target_pred, target_val);
                avg_performance += performance[current_val_set_id];
            }
            avg_performance /= k;
            std::cout << "My average performance is " << avg_performance << std::endl;

            if(avg_performance > bestTestPerformanceValue)
            {
                bestTestPerformanceValue = avg_performance;
                bestC = C;
                bestGamma = gamma;
            }
        }
    }
    svm_para_->C = bestC;
    svm_para_->gamma = bestGamma;
    computeSvmModel(data_train, target_train);

    std::cout << "I achieved the best performance for C=" << bestC << " and gamma=" << bestGamma << ". " << std::endl;
}

template <typename MTPtr>
void MyClassifier::assignClassToId(const boost::shared_ptr<const std::vector<MTPtr> > models)
{
    for(size_t i=0; i < models->size(); i++)
    {
        if(class_map_.find(models->at(i)->class_) == class_map_.end())
        {
            size_t class_label = class_map_.size();
            std::cout << "Class " << models->at(i)->class_
                      << " corresponds to id " << class_label << std::endl;
            class_map_[models->at(i)->class_] = class_label;
        }
    }
}

template <typename MTPtr>
void MyClassifier::assignViewsInClassToId(const boost::shared_ptr<const std::vector<MTPtr> > models, std::vector< std::map <std::string, size_t> > &view_map_per_class_v)
{
    for(size_t i=0; i < models->size(); i++)
    {
        if(view_map_per_class_v[class_map_[models->at(i)->class_]].find(
                    models->at(i)->id_) == view_map_per_class_v[class_map_[models->at(i)->class_]].end())
        {
            size_t model_label = view_map_per_class_v[class_map_[models->at(i)->class_]].size();
            std::cout << "model id " << models->at(i)->id_ << " for class "
                      << models->at(i)->class_ << " corresponds to id "
                      << model_label << std::endl;
            view_map_per_class_v[class_map_[models->at(i)->class_]][models->at(i)->id_] = model_label;

        }
    }
}

void MyClassifier::trainClassifier()
{
    /*std::vector<std::vector<double> > data_train = readMatrixFromFile("/home/thomas/Desktop/data_train.txt");
    std::vector<std::vector<double> > data_test = readMatrixFromFile("/home/thomas/Desktop/data_test.txt");
    std::vector<double> target_train;
    std::vector<double> target_test;

    std::vector<std::vector<double> > tmp = readMatrixFromFile("/home/thomas/Desktop/target_train.txt");
    for(size_t i=0; i<tmp.size(); i++)
        target_train.push_back(tmp[i][0]);

    tmp = readMatrixFromFile("/home/thomas/Desktop/target_test.txt");
    for(size_t i=0; i<tmp.size(); i++)
        target_test.push_back(tmp[i][0]);

    initSVM();
    dokFoldCrossValidation(data_train, target_train, 5);
    std::vector<double> target_pred;
    double test_performance = testSVM(data_test, target_pred, target_test);
    std::cout << "Test performance is " << test_performance*100 << "%." << std::endl;*/

    /* initialize random seed: */
    // srand (time(NULL));

    /*   svm::svm_parameter *svm_para = new svm::svm_parameter;
    svm_para->svm_type = svm::NU_SVR;
    svm_para->kernel_type = svm::POLY;
    svm_para->degree = 2;
    svm_para->gamma = 1;// default 1/k;
    svm_para->coef0 = 1;

    svm_para->cache_size = 100;
    svm_para->eps = 0.001;
    svm_para->C = 10;
    svm_para->nr_weight = 0;
    svm_para->weight_label = NULL;
    svm_para->weight = NULL;
    svm_para->nu = 0.5;
    svm_para->p = 1;
    svm_para->shrinking = 1;
    svm_para->probability = 0;

    svm::svm_problem *svm_prob = new svm::svm_problem;
    svm_prob->l = 80; //number of training examples
    svm_prob->x = new svm::svm_node *[svm_prob->l];
    for(int i = 0; i<svm_prob->l; i++)
        svm_prob->x[i] = new svm::svm_node[2+1];  // 2 dimensional
    svm_prob->y = new double[svm_prob->l];

    for(int i=0; i<svm_prob->l; i++)
    {
        svm_prob->x[i][0].value = 1;
        svm_prob->x[i][1].value = static_cast<double>(i) / 80.0; //scaling
        svm_prob->x[i][0].index = 1;
        svm_prob->x[i][1].index = 2;
        svm_prob->x[i][2].index = -1;
        svm_prob->y[i] = 200 * svm_prob->x[i][1].value +
                3 * svm_prob->x[i][0].value + rand() % 5 - 5;
        std::cout << "i=" << i << ", y=" << svm_prob->y[i] << std::endl;
    }

    svm::svm_node *svm_n_test = new svm::svm_node;
    svm_n_test = new svm::svm_node[2+1];
    svm_n_test[0].value = 1;
    svm_n_test[1].value = 5.5 / 80.0; //scaling
    svm_n_test[0].index = 1;
    svm_n_test[1].index = 2;
    svm_n_test[2].index = -1;
    svm::svm_model *svm_mod = svm::svm_train(svm_prob, svm_para);
    double y_test = svm::svm_predict(svm_mod, svm_n_test);*/

    pImgSource_->setPath(models_dir_);
    pImgSource_->generate();
    models2D_ = pImgSource_->getModels();

    pPCSource_->setPath(models_dir_);
    std::string dummy = "";
    pPCSource_->generate(dummy);
    cast_source_ = boost::static_pointer_cast<faat_pcl::rec_3d_framework::UnregisteredViewsSource<PointT> > (pPCSource_);
    models3D_ = cast_source_->getModels ();

    esf_signatures_.reset(new pcl::PointCloud<ESFFeatureT>());
    esf_signatures_->width = models3D_->size();
    esf_signatures_->height = 1;
    esf_signatures_->resize(models3D_->size());

    // ---Assign class names to unique discrete identifiers ------
    assignClassToId<ModelTPtr>(models3D_);
    assignClassToId<Model2DTPtr>(models2D_);
    num_classes_ = class_map_.size();

    if ( force_retrain_ )
    {
        // ---Assign view names to unique discrete identifiers ------
        std::vector< std::map <std::string, size_t> > view_map_per_class_v;
        view_map_per_class_v.resize(num_classes_);
        assignViewsInClassToId<ModelTPtr>(models3D_, view_map_per_class_v);
        assignViewsInClassToId<Model2DTPtr>(models2D_, view_map_per_class_v);

        size_t num_signatures=0;
        std::vector<std::vector<std::vector<SIFTFeatureT> > >
                sift_signatures_per_class_per_view_v;
        sift_signatures_per_class_per_view_v.resize(num_classes_);

        for(size_t i=0; i<sift_signatures_per_class_per_view_v.size(); i++)
        {
            //check if this is correct
            sift_signatures_per_class_per_view_v[i].resize(view_map_per_class_v[i].size());
        }

        for(size_t i=0; i < models3D_->size(); i++)
        {
            cv::Mat FeatureMatrix;
            compute3DFeatures(models3D_->at(i)->views_->at(0), models3D_->at(i)->indices_->at(0), FeatureMatrix);

            for(size_t kk=0; kk<FeatureMatrix.rows; kk++)
            {
                SIFTFeatureT feature_vec;
                for(size_t jjj=0; jjj < FeatureMatrix.cols; jjj++)
                {
                    feature_vec.histogram[jjj] = FeatureMatrix.at<double>(kk,jjj);
                }
                sift_signatures_per_class_per_view_v[ class_map_[models3D_->at(i)->class_] ]
                        [view_map_per_class_v[class_map_[models3D_->at(i)->class_]][models3D_->at(i)->id_]]
                        .push_back(feature_vec);
            }
            num_signatures += FeatureMatrix.rows;
        }

        for(size_t i=0; i < models2D_->size(); i++)
        {
            cv::Mat FeatureMatrix;
            compute2DFeatures(*(models2D_->at(i)->view_), FeatureMatrix);

            for(size_t kk=0; kk<FeatureMatrix.rows; kk++)
            {
                SIFTFeatureT feature_vec;
                for(size_t jjj=0; jjj < FeatureMatrix.cols; jjj++)
                {
                    feature_vec.histogram[jjj] = FeatureMatrix.at<double>(kk,jjj);
                }
                sift_signatures_per_class_per_view_v[ class_map_[models2D_->at(i)->class_] ]
                        [view_map_per_class_v[class_map_[models2D_->at(i)->class_]][models2D_->at(i)->id_]]
                        .push_back(feature_vec);
            }
            num_signatures += FeatureMatrix.rows;
        }
        //kdtree_.setInputCloud(esf_signatures_);

        siftCodebook_->setNumClusters(80);
        cv::Mat labels(num_signatures,1,CV_32F), descClusterCenters;

        siftCodebook_->computeCodebook(sift_signatures_per_class_per_view_v, num_signatures, labels);
        siftCodebook_->getDescClusterCenters(descClusterCenters);
        std::cout << "labels = "<< std::endl << " "  << labels << std::endl << std::endl << std::endl;
        std::cout << "centers = "<< std::endl << " "  << descClusterCenters << std::endl << std::endl;

        std::vector<std::vector<std::vector<double> > > hist_per_class_per_view_v;
        siftCodebook_->computeHist(sift_signatures_per_class_per_view_v, labels, hist_per_class_per_view_v);
        siftCodebook_->writeHistsToFile(training_dir_, hist_per_class_per_view_v);
        siftCodebook_->writeCodebookToFile(training_dir_);
    }
    else
    {
        siftCodebook_->readCodebookFromFile(training_dir_);
    }
    std::vector<std::vector<double> > data_train;
    std::vector<double> target_train;

    for (size_t class_id=0; class_id<num_classes_-1; class_id++) //without background
    {
        std::stringstream filename_class_hist;
        filename_class_hist << training_dir_ << "/hist_class_" << class_id << ".txt";

        std::vector<std::vector<double> > data_train_class = readMatrixFromFile(filename_class_hist.str(), " ");

        for(size_t i=0; i<data_train_class.size(); i++)
        {
            target_train.push_back(class_id);
            data_train.push_back(data_train_class[i]);
        }
    }
    initSVM();
    shuffleTrainingData(data_train, target_train);
    dokFoldCrossValidation(data_train, target_train, 5);
}

void MyClassifier::shuffleTrainingData(std::vector<std::vector<double> > &data_train, std::vector<double> &target_train)
{
    std::vector<size_t> vector_indices;
    vector_indices.reserve(data_train.size());
    for(size_t i=0; i<data_train.size(); i++)
        vector_indices.push_back(i);
    std::random_shuffle(vector_indices.begin(), vector_indices.end());
    for(size_t i=0; i<data_train.size(); i++)
    {
        std::swap(data_train[i], data_train[vector_indices[i]]);
        std::swap(target_train[i], target_train[vector_indices[i]]);
    }
}

void MyClassifier::classify()
{
    cv::Mat image = cv::imread("/home/thomas/data/Cat50_TestDB_small/image_color/1.png", CV_LOAD_IMAGE_COLOR);
    cv::Mat sift_signatures_mat;
    compute2DFeatures(image, sift_signatures_mat);

    size_t num_signatures = sift_signatures_mat.rows;
    cv::Mat label_test(num_signatures, 1, CV_32S);
    cv::Mat descClusterCenters;
    siftCodebook_->getDescClusterCenters(descClusterCenters);

    for(size_t i=0; i < num_signatures; i++)
    {
        label_test.at<int>(i,0) = 0;
        double shortest_dist= DBL_MAX;
        for(size_t kk=0; kk<descClusterCenters.rows; kk++)
        {
            std::cout << descClusterCenters.row(kk).size() <<
                         descClusterCenters.row(kk).type() <<
                         sift_signatures_mat.row(i).size() <<
                         sift_signatures_mat.row(i).type() << std::endl;
            double dist = cv::norm(descClusterCenters.row(kk), sift_signatures_mat.row(i), cv::NORM_L2);
            if(dist<shortest_dist)
            {
                shortest_dist = dist;
                label_test.at<int>(i,0) = kk;
            }
        }
    }
    std::cout << "labels = "<< std::endl << " "  << label_test << std::endl << std::endl;

    size_t num_clusters = siftCodebook_->getNumClusters();
    std::vector<double> hist_train(num_clusters);
    for(size_t hist_bin_id=0; hist_bin_id < num_clusters; hist_bin_id++)
    {
        hist_train [hist_bin_id]=0;
    }

    for (size_t row_id=0; row_id < label_test.rows; row_id++)
    {
        int hist_bin_id = label_test.at<int>(row_id, 0);
        hist_train [hist_bin_id] += 1;
    }

    for(size_t hist_bin_id=0; hist_bin_id < num_clusters; hist_bin_id++)
    {   //normalize such that sum(hist)=1
        hist_train [hist_bin_id] /= label_test.rows;
    }

    std::vector<std::vector<double> > data_test;
    data_test.push_back(hist_train);
    std::vector<double> target_pred;
    testSVM(data_test, target_pred);
    std::cout << "Predicted class " << target_pred[0] << std::endl;

    if(pInputCloud_->size() <= 0)
    {
        PCL_ERROR("No input cloud defined.");
    }
    else
    {
        pcl::PointCloud<ESFFeatureT>::CloudVectorType esf_signature;
        std::vector<Eigen::Vector3f> centroids;
        pcl::PointCloud<PointT>::Ptr pProcessedCloud;
        pProcessedCloud.reset(new pcl::PointCloud<PointT>());

        esf_estimator_->estimate(pInputCloud_, pProcessedCloud, esf_signature, centroids);
        int K = 10;

        std::vector<int> pointIdxNKNSearch(K);
        std::vector<float> pointNKNSquaredDistance(K);

        if ( kdtree_.nearestKSearch (esf_signature[0].points[0], K, pointIdxNKNSearch, pointNKNSquaredDistance) > 0 )
        {
            for (size_t i = 0; i < pointIdxNKNSearch.size (); ++i)
                std::cout << "  Class:  "  <<   models3D_->at(pointIdxNKNSearch[i])->class_
                          << "  Id:  "  <<   models3D_->at(pointIdxNKNSearch[i])->id_
                          << " (squared distance: " << pointNKNSquaredDistance[i] << ")" << std::endl;
        }
    }
}

void MyClassifier::testClassifier(std::string test_dir)
{
    boost::shared_ptr < faat_pcl::rec_3d_framework::Source2D> pImgSource;
    pImgSource.reset(new faat_pcl::rec_3d_framework::Source2D ());
    pImgSource->setPath(test_dir);
    pImgSource->generate();
    boost::shared_ptr<std::vector<Model2DTPtr> > models2D = pImgSource->getModels();

    boost::shared_ptr < faat_pcl::rec_3d_framework::UnregisteredViewsSource  <PointT>
            > pPCSource;
    pPCSource.reset(new faat_pcl::rec_3d_framework::UnregisteredViewsSource  <PointT>());
    pPCSource->setPath(test_dir);
    std::string dummy = "";
    pPCSource->generate(dummy);
    boost::shared_ptr < faat_pcl::rec_3d_framework::Source<PointT> >cast_source =
            boost::static_pointer_cast<faat_pcl::rec_3d_framework::UnregisteredViewsSource<PointT> > (pPCSource);
    boost::shared_ptr<std::vector<ModelTPtr> > models3D = cast_source->getModels ();

    // ---Assign class names to unique discrete identifiers ------
    assignClassToId<ModelTPtr>(models3D);
    assignClassToId<Model2DTPtr>(models2D);
    num_classes_ = class_map_.size();

    // ---Assign view names to unique discrete identifiers ------
    std::vector< std::map <std::string, size_t> > view_map_per_class_v_test;
    view_map_per_class_v_test.resize(num_classes_);
    assignViewsInClassToId<ModelTPtr>(models3D, view_map_per_class_v_test);
    assignViewsInClassToId<Model2DTPtr>(models2D, view_map_per_class_v_test);

    size_t num_signatures=0;
    std::vector<std::vector<std::vector<SIFTFeatureT> > >
            sift_signatures_per_class_per_view_v;
    sift_signatures_per_class_per_view_v.resize(num_classes_);

    for(size_t i=0; i<sift_signatures_per_class_per_view_v.size(); i++)
    {
        //check if this is correct
        sift_signatures_per_class_per_view_v[i].resize(view_map_per_class_v_test[i].size());
    }

    for(size_t i=0; i < models3D->size(); i++)
    {
        cv::Mat FeatureMatrix;
        compute3DFeatures(models3D->at(i)->views_->at(0), models3D->at(i)->indices_->at(0), FeatureMatrix);

        for(size_t kk=0; kk<FeatureMatrix.rows; kk++)
        {
            SIFTFeatureT feature_vec;
            for(size_t jjj=0; jjj < FeatureMatrix.cols; jjj++)
            {
                feature_vec.histogram[jjj] = FeatureMatrix.at<double>(kk,jjj);
            }
            sift_signatures_per_class_per_view_v[ class_map_[models3D->at(i)->class_] ]
                    [view_map_per_class_v_test[class_map_[models3D->at(i)->class_]][models3D->at(i)->id_]]
                    .push_back(feature_vec);
        }
        num_signatures += FeatureMatrix.rows;
    }

    for(size_t i=0; i < models2D->size(); i++)
    {
        cv::Mat FeatureMatrix;
        compute2DFeatures(*(models2D->at(i)->view_), FeatureMatrix);

        for(size_t kk=0; kk<FeatureMatrix.rows; kk++)
        {
            SIFTFeatureT feature_vec;
            for(size_t jjj=0; jjj < FeatureMatrix.cols; jjj++)
            {
                feature_vec.histogram[jjj] = FeatureMatrix.at<double>(kk,jjj);
            }
            sift_signatures_per_class_per_view_v[ class_map_[models2D->at(i)->class_] ]
                    [view_map_per_class_v_test[class_map_[models2D->at(i)->class_]][models2D->at(i)->id_]]
                    .push_back(feature_vec);
        }
        num_signatures += FeatureMatrix.rows;
    }

    cv::Mat label_test;
    std::vector<std::vector<std::vector<double> > > hist_per_class_per_view_v;
    siftCodebook_->computeLabels(sift_signatures_per_class_per_view_v, num_signatures, label_test);
    std::cout << "labels = " << std::endl << " " << label_test << std::endl << std::endl;
    siftCodebook_->computeHist(sift_signatures_per_class_per_view_v, label_test, hist_per_class_per_view_v);

    std::vector<std::vector<double> > predicted_class_label;
    predicted_class_label.resize(hist_per_class_per_view_v.size());
    for(int class_id=0; class_id<predicted_class_label.size(); class_id++)
    {
        predicted_class_label[class_id].resize(hist_per_class_per_view_v[class_id].size());
        for(int view_id=0; view_id<predicted_class_label[class_id].size(); view_id++)
        {
            svm::svm_node *svm_n_test = new svm::svm_node[hist_per_class_per_view_v[class_id][view_id].size()+1];

            for(int feat_attr_id=0; feat_attr_id < hist_per_class_per_view_v[class_id][view_id].size(); feat_attr_id++)
            {
                svm_n_test[feat_attr_id].value = hist_per_class_per_view_v[class_id][view_id][feat_attr_id];
                svm_n_test[feat_attr_id].index = feat_attr_id+1;
            }
            svm_n_test[hist_per_class_per_view_v[class_id][view_id].size()].index = -1;
            predicted_class_label[class_id][view_id] = svm::svm_predict(svm_mod_, svm_n_test);
        }

    }

}

void MyClassifier::compute3DFeatures(PointInTPtr &inputX, pcl::PointIndices &indices, cv::Mat &FeatureVector)
{
    size_t dimensions = 128;

    PointInTPtr sift_keypoints;
    sift_keypoints.reset(new pcl::PointCloud<PointT>());
    SIFTFeatureTPtr sift_signatures;
    sift_signatures.reset(new pcl::PointCloud<SIFTFeatureT>());
    std::vector<float> sift_scale;
    sift_estimator_->setIndices(indices);
    sift_estimator_->estimate(inputX, sift_keypoints, sift_signatures, sift_scale);

    FeatureVector = cv::Mat(sift_signatures->points.size(), dimensions, CV_64FC1);

    for(size_t i = 0; i < sift_signatures->points.size(); i++)
    {
        for(size_t kk=0; kk < dimensions; kk++)
        {
            FeatureVector.at<double>(i,kk) = sift_signatures->points[i].histogram[kk];
        }
    }

    /*pcl::PointCloud<ESFFeatureT>::CloudVectorType esf_signature;
    std::vector<Eigen::Vector3f> centroids;
    pcl::PointCloud<PointT>::Ptr pFilteredCloud, pProcessedCloud;
    pFilteredCloud.reset(new pcl::PointCloud<PointT>());
    pProcessedCloud.reset(new pcl::PointCloud<PointT>());
    pcl::copyPointCloud(*(models3D_->at(i)->views_->at(0)), indices, *pFilteredCloud);
    //std::vector<PointT> test = pFilteredCloud->points();
    esf_estimator_->estimate(pFilteredCloud, pProcessedCloud, esf_signature, centroids);
    for(int kk=0; kk<640; kk++)
    {
        esf_signatures_->points[i].histogram[kk] = esf_signature[0].points[0].histogram[kk];
    }*/

    /*Eigen::Vector4f centroid;
    Eigen::Matrix3f covariance_matrix;
    pcl::PointCloud<PointT>::Ptr pClusterPCl_transformed (new pcl::PointCloud<PointT>());
    pcl::computeMeanAndCovarianceMatrix(*(models3D->at(i)->views_->at(0)), covariance_matrix, centroid);
    //Eigen::EigenSolver<Eigen::Matrix3f> es(covariance_matrix);
    //std::cout << "eigenvector and eigenvalues for cluster " << i << std::endl;
    //Eigen::Matrix3f eigenvec_matrix = es.eigenvectors().real();
    //std::cout << es.eigenvalues().real() << std::endl << " vec: " << es.eigenvectors().real() << std::endl;
    Eigen::Matrix3f eigvects;
    Eigen::Vector3f eigvals;
    pcl::eigen33(covariance_matrix, eigvects,  eigvals);
    //std:cout << "PCL Eigen: " << std::endl << eigvals << std::endl << eigvects << std::endl;

    Eigen::Vector3f centroid_transformed = eigvects.transpose() * centroid.topRows(3);

    Eigen::Matrix4f transformation_matrix = Eigen::Matrix4f::Zero(4,4);
    transformation_matrix.block<3,3>(0,0) = eigvects.transpose();
    transformation_matrix.block<3,1>(0,3) = -centroid_transformed;
    transformation_matrix(3,3) = 1;

    pcl::transformPointCloud(*(models3D->at(i)->views_->at(0)), *pClusterPCl_transformed, transformation_matrix);

    //pcl::transformPointCloud(*frame_, cluster_indices_int, *frame_eigencoordinates_, eigvects);
    PointT min_pt, max_pt;
    pcl::getMinMax3D(*pClusterPCl_transformed, min_pt, max_pt);
    std::cout << "Elongations along eigenvectors: " << max_pt.x - min_pt.x << ", " << max_pt.y - min_pt.y
              << ", " << max_pt.z - min_pt.z << std::endl;*/
}

void MyClassifier::compute2DFeatures(const cv::Mat &inputX, cv::Mat &FeatureVector)
{
    size_t dimensions = 128;
    std::vector<SiftGPU::SiftKeypoint> keypoints;
    SIFTFeatureTPtr sift_signatures;
    sift_signatures.reset(new pcl::PointCloud<SIFTFeatureT>());
    std::vector<float> sift_scale;
    sift_estimator_->estimate(inputX, keypoints, sift_signatures, sift_scale);

    FeatureVector = cv::Mat(sift_signatures->points.size(), dimensions, CV_64FC1);

    for(size_t i = 0; i < sift_signatures->points.size(); i++)
    {
        for(size_t kk=0; kk < dimensions; kk++)
        {
            FeatureVector.at<double>(i,kk) = sift_signatures->points[i].histogram[kk];
        }
    }
    //std::cout << "FeatureVector: " << std::endl << FeatureVector << std::endl << std::endl;
}

