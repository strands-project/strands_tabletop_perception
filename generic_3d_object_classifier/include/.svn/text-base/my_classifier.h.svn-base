#ifndef MY_CLASSIFIER_H
#define MY_CLASSIFIER_H

#define EIGEN_YES_I_KNOW_SPARSE_MODULE_IS_NOT_STABLE_YET

#include <vector>
#include <cv.h>
#include <ros/ros.h>
#include <pcl/common/common.h>
#include <pcl/kdtree/kdtree_flann.h>
#include <pcl/ml/kmeans.h>
#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl/io/io.h>

#include <faat_pcl/3d_rec_framework/pc_source/unregistered_views_source.h>
#include <faat_pcl/3d_rec_framework/img_source/source2d.h>
#include <faat_pcl/3d_rec_framework/feature_wrapper/local/image/sift_local_estimator.h>
#include <faat_pcl/3d_rec_framework/feature_wrapper/global/esf_estimator.h>
#include <faat_pcl/3d_rec_framework/pipeline/local_recognizer.h>

#include <v4r/svm/svm.h>
#include "visual_codebook.h"
//#include <v4r/svm/SVMTrainModel.h>
typedef pcl::PointXYZRGB PointT;
typedef pcl::PointCloud<PointT>::Ptr PointInTPtr;
typedef pcl::Histogram<128> SIFTFeatureT;
typedef pcl::PointCloud<SIFTFeatureT>::Ptr SIFTFeatureTPtr;
typedef pcl::ESFSignature640 ESFFeatureT;
typedef pcl::PointCloud<ESFFeatureT>::Ptr ESFFeatureTPtr;
typedef faat_pcl::rec_3d_framework::Model<PointT> ModelT;
typedef faat_pcl::rec_3d_framework::Model2D Model2DT;
typedef boost::shared_ptr<ModelT> ModelTPtr;
typedef boost::shared_ptr<Model2DT> Model2DTPtr;

class MyClassifier
{
private:
    pcl::PointCloud<PointT>::Ptr pInputCloud_;
    std::string models_dir_, training_dir_;
    pcl::KdTreeFLANN<ESFFeatureT> kdtree_;
    ros::NodeHandle *n_;
    std::string test_filename_;
    boost::shared_ptr < faat_pcl::rec_3d_framework::UnregisteredViewsSource  <PointT>
            > pPCSource_;
    boost::shared_ptr < faat_pcl::rec_3d_framework::Source2D> pImgSource_;
    boost::shared_ptr < faat_pcl::rec_3d_framework::Source<PointT> > cast_source_;
    boost::shared_ptr<std::vector<ModelTPtr> > models3D_;
    boost::shared_ptr<std::vector<Model2DTPtr> > models2D_;
    boost::shared_ptr < faat_pcl::rec_3d_framework::ESFEstimation<PointT, ESFFeatureT > > esf_estimator_;
    pcl::PointCloud<ESFFeatureT>::Ptr esf_signatures_ ;
    boost::shared_ptr < faat_pcl::rec_3d_framework::SIFTLocalEstimation<PointT, SIFTFeatureT > >
        sift_estimator_;
    std::map<std::string, size_t> class_map_;
    svm::svm_parameter *svm_para_;
    svm::svm_model *svm_mod_;
    boost::shared_ptr <VisualCodebook<SIFTFeatureT> > siftCodebook_;
    bool force_retrain_;
    size_t num_classes_;

public:
    MyClassifier()
    {
        num_classes_ = 0;
        training_dir_ = "";
        force_retrain_ = false;
        pInputCloud_.reset(new pcl::PointCloud<PointT>());
        models_dir_ = "/home/thomas/data/Cat50_TestDB_small/pcd_binary";
        svm_para_ = new svm::svm_parameter;
        siftCodebook_.reset(new VisualCodebook<SIFTFeatureT>());
        pImgSource_.reset(new faat_pcl::rec_3d_framework::Source2D ());
        pPCSource_.reset(new faat_pcl::rec_3d_framework::UnregisteredViewsSource  <PointT>());
        sift_estimator_.reset (new faat_pcl::rec_3d_framework::SIFTLocalEstimation<PointT, SIFTFeatureT >());
        esf_estimator_.reset (new faat_pcl::rec_3d_framework::ESFEstimation<PointT, ESFFeatureT >());
    }

    void init(int argc, char ** argv);
    void setInputCloud(pcl::PointCloud<PointT> &cloud);
    void trainClassifier();
    void classify();
    std::vector<std::vector<double> > readMatrixFromFile(std::string filename, std::string delimiter = ",");
    double testSVM(const std::vector<std::vector<double> > & data_test, std::vector<double> &target_pred, const std::vector<double> &target_test = std::vector<double>());
    void initSVM();
    void computeSvmModel(std::vector<std::vector<double> >data_train, std::vector<double> target_train);
    void dokFoldCrossValidation(std::vector<std::vector<double> >data_train, std::vector<double> target_train, int k=1);

    template <typename MTPtr>
    void assignClassToId(const boost::shared_ptr<const std::vector<MTPtr> > models);

    template <typename MTPtr>
    void assignViewsInClassToId(const boost::shared_ptr<const std::vector<MTPtr> > models, std::vector< std::map <std::string, size_t> > &view_map_per_class_v);
    void testClassifier(std::string test_dir);
    void compute3DFeatures(PointInTPtr &inputX, pcl::PointIndices &indices, cv::Mat &FeatureVector);
    void compute2DFeatures(const cv::Mat &inputX, cv::Mat &FeatureVector);
    void shuffleTrainingData(std::vector<std::vector<double> > &data_train, std::vector<double> &target_train);
};

#endif //MY_CLASSIFIER_H
